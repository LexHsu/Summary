内联函数
===

如果一个函数被指定为inline，则在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替代。
inline是利用空间换取时间的做法，是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。
如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。
所以，如果函数体代码过长或者函数体重有循环语句，if语句或switch语句或递归时，不宜用内联。

例如，例如

```c++
int min(int v1, int v2)
{
    return( v1 < v2 << v1 : v2 );
}

// 使用举例
int minVal2 = min( i, j );
// 在编译时被展开为
int minVal2 = i < j << i : j;
```

关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。内联函数调用前必须声明。

```c++
// inline 仅与函数声明放在一起
inline void Foo(int x, int y);
void Foo(int x, int y)
{
    // ...
}
```

以上代码是错误的不能成为内联函数，下面的才是正确的：

```c++
void Foo(int x, int y);
// inline 与函数定义体放在一起
inline void Foo(int x, int y)
{
    // ...
}
```

可见，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。
对于以上例子，只在定义前加上inline，而不是在声明和定义前都加，表明一个基本原则：声明与定义不可混为一谈。

### 总结

内联可理解为C++中对于函数专有的宏，是对于C的函数宏的一种改进。对于常量宏，C++提供const替代；而对于函数宏，C++提供的方案则是inline。
在C中，宏的优势在于编译器通过复制宏代码的方式，省去了参数压栈，生成汇编的call调用，返回参数等操作，虽然存在一些安全隐患，但提升了效率。
不过函数宏还是有不少缺陷的，主要有：

1. 使用宏，无法进行调试，虽然windows提供了ASSERT宏。
2. 使用宏，无法访问类的私有成员。
3. 在复制代码时，容易出现一想不到的边际效应，比如经典的

```c++
#define MAX(a, b) (a) > (b) ? (a) : (b)

// 执行时
#define MAX(a, b) (a) > (b) ? (a) : (b)
// 等价于
result = (i) > (j) ? (i) : (j) + 2;
```

可见，C++ 通过内联机制，既具备宏代码的效率，又增加了安全性，还可以自由操作类的数据成员，算是一个比较完美的解决方案。
