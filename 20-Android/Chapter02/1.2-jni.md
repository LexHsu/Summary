JNI
===

Android NDK开发指Java层通过JNI（Java Native Interface）与原生代码如（C，C++等）进行交互，步骤如下：

1. 设计JNI接口。
2. 使用C(CPP)实现本地方法。
3. 生成动态链接库so文件。
4. 将so文件复制到Java工程，运行即可。


### 设计JNI接口
创建Android工程，新建一个java文件，命名为Jni，代码如下：

```java
public class HelloJni extends Activity {
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        /* Create a TextView and set its content.
         * the text is retrieved by calling a native
         * function.
         */
        TextView  tv = new TextView(this);
        tv.setText( stringFromJNI() );
        setContentView(tv);
    }

    /* A native method that is implemented by the
     * 'hello-jni' native library, which is packaged
     * with this application.
     */
    public native String  stringFromJNI();

    /* This is another native method declaration that is *not*
     * implemented by 'hello-jni'. This is simply to show that
     * you can declare as many native methods in your Java code
     * as you want, their implementation is searched in the
     * currently loaded native libraries only the first time
     * you call them.
     *
     * Trying to call this function will result in a
     * java.lang.UnsatisfiedLinkError exception !
     */
    public native String  unimplementedStringFromJNI();

    /* this is used to load the 'hello-jni' library on application
     * startup. The library has already been unpacked into
     * /data/data/com.example.hellojni/lib/libhello-jni.so at
     * installation time by the package manager.
     */
    static {
        System.loadLibrary("hello-jni");
    }
}
```

### 使用C或C++实现原生方法
在工程目录下，新建一个jni文件夹。创建hello-jni.c文件。

```c
#include <string.h>
#include <jni.h> // Jni所有接口都定义在Jni.h中，通常在NDK程序中都要包含该头文件

/* This is a trivial JNI example where we use a native method
 * to return a new VM String. See the corresponding Java source
 * file located at:
 *
 *   src/com/example/hellojni/HelloJni.java
 */
jstring Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz )
{
    return (*env)->NewStringUTF(env, "Hello from JNI");
}
```

### 生成动态链接库so文件

在原生代码目录下建立一个Android.mk文件：

```makefile
LOCAL_PATH := $(call my-dir)    # 宏函数’my-dir’由编译系统提供，用于返回当前路径，以便查找源文件
include $(CLEAR_VARS)           # 清除许多LOCAL_XXX变量，如LOCAL_MODULE,LOCAL_SRC_FILES等
LOCAL_MODULE:= hello-jni        # so文件名，系统会自动增加lib前缀和.so后缀
LOCAL_SRC_FILES := hello-jni.c  # 要编译的源码文件，不需要列出头文件和包含文件，系统自动加入依赖文件
include $(BUILD_SHARED_LIBRARY) # 编译为动态库，要编译.a动态库使用BUILD_STATIC_LIBRARY
```

进入原生代码目录执行：$NDK/ndk-build

此时会在工程目录下生成libs目录，在libs/armeabi/目录中会生成libhello-jni.so文件，将so文件载入到Android工程中即可。

### JNI基本数据类型

|  Java类型  |    原生类型    |    描述  |
|:---------:|:-------------:|:--------:|
| boolean   | jboolean   | unsigned 8 bits
| byte   | jbyte   | unsigned 8 bits
| char   | jchar   | unsigned 16 bits
| short   | jshort   | signed 16 bits
| int   | jint   | signed 32 bits
| long   | jlong   | signed 64 bits
| float   | jfloat   | 32 bits
| double   | jdouble   | 64 bits
