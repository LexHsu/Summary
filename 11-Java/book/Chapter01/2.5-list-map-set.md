
List, Set, Map
=========

### List，Set，Map的类层次关系：

```
Collection
    |---- List
        |---- LinkedList
        |---- ArrayList
        |---- Vector
            |---- Stack
        |---- Set

Map
    |---- Hashtable
    |---- HashMap
    |---- WeakHashMap
```

### 遍历 Collection

```
Iterator it = collection.iterator(); // 获得一个迭代子
while (it.hasNext()) {
    Object obj = it.next();          // 获取下一个元素
}
```

### List

List 是有序的 Collection，与 Set 不同，List 允许有相同的元素。

```
1. LinkedList
可被用作堆栈（stack），队列（queue）或双向队列（deque）。
允许null元素。
无同步方法。多个线程同时访问一个List，需自行实现访问同步，如：
List list = Collections.synchronizedList(new LinkedList());

2. ArrayList
ArrayList实现了可变大小的数组。
允许null元素。
无同步方法。
需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。

3. Vector
可理解为带同步的ArrayList。
Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%

4. Stack
继承自Vector。
```

### Set

Set不包含重复元素，因此最多有一个 null 元素。


### Map

注意，Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。

##### Hashtable, HashMap

```
1. HashTable的方法是同步的，HashMap是非同步的。
2. HashTable不允许null值(key和value都不可以),HashMap允许null值(key和value都可以)。
4. HashTable使用Enumeration，HashMap使用Iterator。
5. HashTable中hash数组默认大小是11，增加方式是 old*2+1。HashMap中默认大小是16，增加方式是2的指数。
6. 哈希值的使用不同。
HashTable直接使用对象的hashCode：
int hash = key.hashCode();
int index = (hash & 0x7FFFFFFF) % tab.length;

HashMap重新计算hash值，而且用与代替求模：
int hash = hash(k);
int i = indexFor(hash, table.length);

static int hash(Object x) {
    int h = x.hashCode();
    h += ~(h << 9);
    h ^= (h >>> 14);
    h += (h << 4);
    h ^= (h >>> 10);
    return h;
}

static int indexFor(int h, int length) {
    return h & (length-1);
}
```

由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方法。
hashCode和equals方法继承自根类Object，按照散列函数的定义：

- 如果两个对象相同，即obj1.equals(obj2)为真，则它们的hashCode相同
- 如果两个对象不同，则它们的hashCode有可能相同

如果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希表的操作。
如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null）
因此，要同时覆写equals方法和hashCode方法。

##### WeakHashMap

WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。

### 总结

在ArrayList和Vector中，从一个指定的位置（通过索引）查找数据或是在集合的末尾增加、移除一个元素所花费的时间复杂度都是 O(1)。
但如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。
因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行位移的操作。
LinkList集合类在增加或移除集合中任何位置的元素所花费的时间都是一样的?O(1)，但其索引元素较慢。

因此，涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。

而对于执行效率要求高的程序，也可用数组代替Vector或ArrayList。因为使用数组避免了同步、额外的方法调用和不必要的重新分配空间的操作。
