设计原理及说明
===

### 4.1 分离组帧层与应用层
组帧层和HTTP层并不是严格区别的，分离这两个层是为了方便描述。其实本文的很多地方也都将组帧层与HTTP层放在一起阐述，如stream中的请求响应，HEADERS的定义及压缩等等。

### 4.2 错误处理-组帧层
SPDY中的错误处理分为两部分，只影响单独的stream和影响整个连接错误。当一个错误仅局限于一个stream时，SPDY会发送RST_STREAM帧，使该stream停止，但是不会影响其他的stream处理。而对于发生在单个stream之外的错误，则会导致整个session异常，从而使连接关闭。

### 4.3 每个域名一个连接
相对于其他传统协议，SPDY尽量使用较少的连接。使用多个连接很难保持一致的性能（如压缩，优先序列等），SPDY发送的数据包总量可不HTTP少40%。使用多个连接也不是没有优点，SPDY的复用，当个独立的stream会导致传输层队头阻塞问题（head-of-line blocking），经测试，队头阻塞带来的负面影响超过了压缩和优先序列带来的优势。

### 4.4 固定的vs可变长度字段（Fixed vs Variable Length Fields）
对于一些小数据的处理，SPDY虽然也能使用可变长度字段，但更倾向于使用32bit的固定长度字段。这看起来是浪费带宽，但其简单的编码方式，能提高速度及易用性。
SPDY的目标是降低网络延迟。SPDY帧的开销通常非常低。平均每传输1452字节数据仅有8字节的开销（~0.6%）。现今宽带网络已经普及，且带宽越来越大。世界范围内平均带宽为1Mbps，假设变长编码可降低50%的开销，使用变长编码可使延迟保持在100纳秒以内。更有趣的是较大的编码会强制一个包的边界，这会导致往返周期的减少。然而，通过攻关SPDY和TCP交互的其他方面，相信完全可以减轻这种影响。

### 4.5 Compression Context(s)
当与多个源通信时，有几个选择来隔离压缩上下文。每一个源均维护一个压缩上下文的map（或list）用于每个源。最基本的情况是很容易的 - 每个HEADERS需要识别用于那个帧的上下文。无论如何，压缩上下文开销不小，所以要限制每个上下文的生命周期。对于代理服务器，会产生很多上下文，这点我们要关注。我们可以考虑一组静态的上下文，比如16个，来限制内存使用。我们也可以考虑动态上下文，它可以动态创建，使用之后再销毁。上述方案都很复杂，有很多问题需要解决。
另外，还可选择一个简单的方法，提供一个标识用来重置压缩上下文。通常情况下（非代理）效果不错。因为请求是同源的，不需要重置上下文。对于在一个SPDY会话中使用两个不同的源时，我们仅仅在每次转换间重置压缩状态。

### 4.6 单向Stream（Unidirectional streams）
许多读者注意到单向的stream既有点混乱又有点多余。如果stream中的接收端想要发送数据，其会发送一个带有FLAG_FIN标识的SYN_REPLY帧。因此FLAG_UNIDIRECTIONAL其实不需要了。
的确不需要UNIDIRECTIONAL标记，其避免了接收push的stream的一端，发送一系列空帧（如带有FLAG_FIN标识的SYN_STREAM）。

### 4.7 Data Compression
通常stream中数据部分的压缩不知道stream的内容是多余的。在已经压缩的stream中已经没有值可以被压缩。因此，SPDY允许数据压缩是可选的。、研究发现，许多网站没有使用压缩，影响用户体验。在SPDY层，需要一种机制，开发者可以简单的选择强制压缩 - 毕竟二次压缩比不压缩好。
总体而言，这个特性是可选的并且有时是多余的，暂不清楚它是否有用。因此我们从规范中把它去掉了。


### 4.8 Server Push
一个细微的但是重要的一点是关于服务端push，push的stream必须在associated stream之前声明，这样代理会有一个生命周期，其可丢弃之前stream的信息。
