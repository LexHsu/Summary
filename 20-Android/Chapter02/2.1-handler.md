Handler
===


### Handler的作用

Android主线程中的操作超过5秒还未完成，会出现ANR。因此对于耗时操作如联网读取数据或读取本地较大文件，需要放在子线程中处理，而Android更新UI只能在主线程中，Handler就承担着传递子线程消息, 放入主线程队列中，配合主线程进行更新UI。
Handler常用来传递Message或Runnable：


### Message与Runnable

子线程可通过两种方式的Handler与主线程通信：message和Runnable对象实质都是将在Handler的队列中放入内容，
message是放置信息，可以传递一些参数，Handler获取这些信息并将判度如何处理，而Runnable则是直接给出处理的方法。
这些队列中的内容（无论Message还是Runnable）可以要求马上执行，延迟一定时间执行或者指定某个时刻执行，如果将他们放置在队列头，则表示具有最高有限级别，立即执行。

- Message常用方法

```java
// 发送一个空的Message对象，仅带有what值标识
// 如果Message对象被成功加入消息队列返回true，反之返回false
public final boolean sendEmptyMessage (int what)

// 推送一个Message对象至消息队列的末尾，将在相应handler的handleMessage中被接收到。
// 如果Message对象被成功加入消息队列返回true，反之返回false
public final boolean sendMessage (Message msg)

// 其与obtainMessage()相近。是从全局message池中返回一个Message对象，更高效的复用
// 参数返回的message对象可设置what, obj, arg1, arg2 值
public final Message obtainMessage (int what, int arg1, int arg2, Object obj)

// 清除消息队列中所有带有指定token的，等待执行的runnable对象
// r对象并没有销毁，只是将r的引用从消息队列里拿出来。
public final void removeCallbacks (Runnable r, Object token)

// 移除消息队列中，所有等待处理的Runnable对象r，r对象并没有销毁，只是将r的引用从消息队列里拿出来
public final void removeCallbacks (Runnable r)
```

- Runnable常用方法

```java
// 将Runnable对象r加入消息队列。该Runnable对象运行在handler所依附的线程中
// 如果成功加入了消息队列返回true，否则返回false
// 返回false经常是因为looper处理在消息中已经存在
public final boolean post (Runnable r)

// 将Runnable对象r加入消息队列，并在指定的时间运行
public final boolean postAtTime (Runnable r, long uptimeMillis)

// 将Runnable对象r加入消息队列，并在延迟指定时间之后运行
public final boolean postDelayed (Runnable r, long delayMillis)
```

一般推荐使用Messge方式，因为它可实现更灵活的需求，如执行代码后进入相应回调。而Runnable在某些简单明确的方式中使用。


### Handler传递Message对象


在Android中，线程分为有消息循环的线程和没有消息循环的线程，线程默认没有消息循环。有消息循环的线程一般都会有一个Looper，这个是android中的新概念。主线程（UI线程）就是一个消息循环的线程。针对这种消息循环的机制，就要用到Handler，因为Handler可以传递Message对象。如果要在线程中运行消息循环。必须在线程中先调用prepare()创建一个运行循环；然后调用loop()处理消息直到循环结束。有消息循环，就要往消息循环里面发送相应的消息，自定义消息一般都会有自己对应的处理，消息的发送和清除，消息的处理，把这些都封装在Handler里面，
【注】Handler只是针对那些有Looper的线程，不管是UI线程还是子线程，只要你有Looper，我就可以往你的消息队列里面添加东西，并做相应的处理。Android中只要是关于UI相关的东西，就不能放在子线程中，因为子线程是不能操作UI的，只能进行数据、系统等其他非UI的操作。
在有消息循环的线程中，如何得到Looper的句柄呢？

```java
Looper.myLooper(); // 获得当前的Looper
Looper.getMainLooper ()  // 获得UI线程的Lopper
```

Handle的初始化函数中，如果没有参数，那么他就默认使用的是当前的Looper，如果有Looper参数，就是用对应的线程的Looper。
如果一个线程中调用Looper.prepare()，那么系统就会自动的为该线程建立一个消息队列，然后调用 Looper.loop()之后就进入了消息循环，这个之后就可以发消息、取消息、和处理消息。这个如何发送消息和如何处理消息可以再其他的线程中通过Handler来做，但前提是我们的Handle知道这个子线程的Looper，但是你如果不是在子线程运行 Looper.myLooper()，一般是得不到子线程的looper的。
看下面的代码：
```java
class MyThread extends Thread{
    public void run() {
          Looper.prepare();
          mHandler = new Handler() {
              public void handleMessage(Message msg) {
                  // process incoming messages here
              }
          };
          Looper.loop();
      }
}
```
【注】很多人都像上面这样直接在子线程中新建handler，然后在子线程中发送消息，这样是不对的，失去了多线程的意义。应该让其他的线程(主线程)来控制我们的handler，把 private EHandler mHandler ;放在run方法外面，这样我们的发消息和处理消息都可以在外面来定义，这样增加程序代码的美观，结构更加清晰。优化后如下：
```java
class MyThread extends Thread{
 private EHandler mHandler ;
 public void run() {
 Looper myLooper, mainLooper;
 myLooper = Looper.myLooper ();
                mainLooper = Looper.getMainLooper ();
 String obj;
 if (myLooper == null ){
              mHandler = new EHandler(mainLooper) {
                            public void handleMessage(Message msg) {
                                 // process incoming messages here
                            }
                        };
 obj = “current thread has no looper!” ;
 } else {
 mHandler = new EHandler(myLooper);
 obj = “This is from current thread.” ;
 }
 mHandler .removeMessages(0);
 Message m = mHandler .obtainMessage(1, 1, 1, obj);
 mHandler .sendMessage(m); // 也可以用m.sendToTarget();

             }
  }
```
对任何的Handle，里面必须要重载一个函数public void handleMessage(Message msg)。这个函数用于处理接收的消息，但是这个handler可以根据获取looper决定运行在主线程还是子线程。在需要发送消息的地方，先通过 obtainMessage获取Message对象，如myMessage = mHandler.obtainMessage();。任何一个handler发送消息都是到自身的handleMessage中，(我原先以为子线程新建的handler可以发送消息到主线程中自行new的mHandler，这是错误的。其实是handle可以绑定的不同的线程，如主线程的Handler可以绑定到子线程，子线程的handler可以绑定到主线程)。
然后设置传递的信息，如，
myMessage.what=ok;
myMessage.arg1=1;
然后通过sendMessage等发送消息，给Handler的处理函数handleMessage(Message msg)去处理。 其中removeMessages(0)来清除消息队列。
【注】子线程若想改变UI，千万不可在子线程中去修改，应获得UI线程的Looper，然后发送消息即可，给主线程中Handler的处理函数handleMessage(Message msg)去处理。


### Handler传递Runnable对象


Ruannable对象的run方法可以立刻执行某个操作，也可以在指定时间后执行（也可称为预约执行）。
Handler类主要可以使用如下3个方法来设置执行Runnable对象的时间(时间单位是毫秒)：
```java
public final boolean post(Runnable r);
//  立即执行Runnable对象  
public final boolean postAtTime(Runnable r, long uptimeMillis);
//  在指定的时间（uptimeMillis）执行Runnable对象
public final boolean postDelayed(Runnable r, long delayMillis);
//  在指定的时间间隔（delayMillis）执行Runnable对象  

从上面3个方法可以看出，第1个参数的类型都是Runnable，因此，在调用这3个方法之前，需要有一个实现Runnable接口的类，在Runnable接口中只有一个run方法，该方法为线程执行方法。如果某个类实现了Runnable接口。可以使用如下代码指定在5秒后调用run方法：
    Handler handler = new Handler();  
    handler.postDelayed(this, 5000);
如果想在5秒内停止计时，可以使用如下代码：
    handler.removeCallbacks(this);
除此之外，还可以使用postAtTime方法指定未来的某一个精确时间来执行Runnable对象，代码如下：
    Handler handler = new Handler();  
    handler.postAtTime(runnableObject, android.os.SystemClock.uptimeMillis() + 15 * 1000);  // 15秒后执行Runnable对象
【注】
1. SystemClock.uptimeMillis()  // 从开机到现在的毫秒数（手机睡眠的时间不包括在内）
2. System.currentTimeMillis()   // 从1970年1月1日 UTC到现在的毫秒数，注意该值随手机时间更改后改变

postAtTime的第2个参数表示一个精确时间的毫秒数，如果从当前时间算起，需要使用android.os.SystemClock.uptimeMillis()获得基准时间，即开机到现在的时间。
【注】不管使用哪个方法来执行Runnable对象，都只能运行一次。如果想循环执行，必须在执行完后再次调用post、postAtTime或postDelayed方法。例如，在Main类的run方法中再次调用了postDelayed方法：
    public void run(){  
        tvCount.setText("Count：" + String.valueOf(++count));  
        //  再次调用postDelayed方法，5秒后run方法仍被调用，然后再一次调用postDelayed方法，这样就形成了循环调用  
        handler.postDelayed(this, 5000);  
    }
```
运行本例后，单击【开始计数】按钮，5秒后，会在按钮上方显示计数信息。
然后单击【15秒后显示Toast信息框】按钮，过15秒后，会显示一个Toast信息框。


### Message

即发送的消息对象，Android的Bundle对象可以封装String、Integer以及二进制对象，我们通过在线程中使用Handler对象的sendEmptyMessage或sendMessage方法来传递一个Bundle对象到Handler处理器，Handler类提供了重写方法handleMessage(Message msg) 来判断，通过msg.what来区分每条信息。将Bundle解包来实现Handler类更新UI线程中的内容实现控件的刷新操作。相关的Handler对象有关Message消息发送sendXXXX相关方法，同时还有Runnable的postXXXX相关方法，区别是一个为发送后直接返回，一个为处理后才返回。
另外，Message.obtain方法的作用是从Message Pool中取出一个Message，如果Message Pool中已经没有Message可取则新建一个Message返回，同时用对应的参数给得到的Message对象赋值。 message Pool 我的理解就是一个缓存区。就是把用过的Message放进这里面为了以后用而已。要不每次都要new一个message起步麻烦。这个应该跟String pool的原理类似。

2.  MessageQueue

顾名思义就是消息队列，存放Message

3.  Looper

我暂且叫他循环体吧。 主要就是从MessageQueue中读取消息。Looper就像一个管道工，主要作用是循环迭代MessageQueen，加入新的Message，轮到这条消息时再发送出去。
Looper是跟线程关联的，Android中每一个线程都有一个Looper。UI主线程里初始化时自动调用prepareMainLooper生成自己的Looper，并且自带一个消息队列(MessageQueen)，即messagequeue在Looper创建的时候就生成了。
我们在Hander handler=new Handler（）；
其实就已经把主线程的Looper关联上来了，
有了Looper也就有了MessageQueue 所以handler在调用sendMessage的时候就把这个Message发送到由Looper创建的MessageQueue里。由于该Looper由主线程创建的，当然消息会在主线程处理了。这样就实现了简单的线程间，当时上面的handler并没有新建线程，而是在UI线程里。那好，如果现在我要创建子线程的Looper呢 然后怎么把这个Looper绑定Handler上呢。其实很简单 在子线程调用Looper.prepare()就可以创建子线程的Looper 然后通过Looper.myLooper()就可以拿到这个Looper对象，最后就是把这个Looper 跟Handler绑定起来。其实在构建handler对象的时候我们除了默认无参构造方法，还有有参的构造方法，就是传Looper的。这样就可以把Looper跟Handler绑定起来了。这样在主线程调用handler.sendMessage就可以把message发到子线程里了。这样就实现主线程到子线程的通信了。以此类推各种样式的通信都是可以的。
Looper和Handler没有什么关系，我们从开源的代码可以看到Android还提供了一个Thread继承类HanderThread可以帮助我们处理，在HandlerThread对象中可以通过getLooper方法获取一个Looper对象控制句柄，我们可以将其这个Looper对象映射到一个Handler中实现一个线程同步机制，Looper对象的执行一定要初始化Looper.prepare方法，同时退出时还要释放资源，使用Looper.release方法。

4.  Handler

当然就是处理发来的消息了。
而Handler就像包工头，可以直接操作Looper，例如：
Handler mHandler = new Handler(Looper.getMainLooper);mHandler对象控制UI主线程的Looper对象，即间接控制MessageQueen。
Handler mHandler = new Handler(Looper.myLooper);就是控制当前线程(也可能是UI主线程)的MessageQueen。
Handler间接控制了各个线程的MessageQueen来实现主线程与子线程的相互通信，传递消息队列，分派任务等复杂工作。
Handler还有一个用处，就是缓和任务冲突。当UI急需更新但是任务却在繁忙状态时，为了避免被系统杀死，这时最好利用Handler发送简单消息通知UI主线程更新界面，UI主线程在运行时会在空闲时取出消息解析运行，这样就不会造成任务冲突了。但是这样也可能会造成界面看起来一卡一卡的，最好的办法还是开辟一个新的线程来分摊工作。有些没有界面的任务比如Service运行时需要更新UI界面，例如弹出对话框(Dialog)，那就得通过Handler来发送消息，通知UI线程更新界面，这样才能弹出对话框。

下面我就把这个四个联系起来，看看他们在内部到底怎么执行。
首先通过handler发出一条消息，发送到MessageQueue消息队列里，
接着通过Loop从MessageQueue中从前往后取出Message，
然后通过Handler的dispatchMessage函数进行消息的处理（可见消息的处理是Handler负责的），
消息处理完了以后通过Message对象的recycle(回收利用)函数放到Message Pool中，以便下次使用，通过Pool的处理提供了一定的内存管理从而加速消息对象的获取。
大致流程就是handler通过相应的looper发送message---->>放入MessageQueue队列中---->>Looper从messagequeue中取出message----->>触发handler的消息分发函数调用handler中定义的方法。

【注】
每个线程可以有多个Handler，但只能有一个Looper，各个Handler可通过获取不同的Looper，如Handler mHandler = new Handler(Looper.getMainLooper)，就是将消息发到UI线程的MessageQueue中，然后由主线程的Looper自行处理mHandler的handleMessage回调（发送Message对象的每个handler都要重载handleMessage方法，该方法有可能关联在主线程中或者子线程中）。
Handler一般不用在游戏中，而应用于应用程序中，使用Handler传递Message对象，如点击一个按钮时，传递信息给UI线程去更新主界面，更新列表，或者使用Handler传递Runnable对象，如设计欢迎界面，几秒后跳转到应用的主界面。
