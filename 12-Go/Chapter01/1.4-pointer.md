
指针
=========

支持指针类型 `*T`，指针的指针 `**T`，以及包含包名前缀的 `*<package>.T`。
- 默认值 nil，不是 NULL。
- 操作符 `&` 取变量地址，`*` 透过指针访问目标对象。
- 不支持指针运算，不支持 `->` 运算符,直接用 `.` 访问目标成员。

```go
func main() {
    type data struct{ a int }
    var d = data{1234}
    var p *data
    p = &d
    fmt.Printf("%p, %v\n", p, p.a) // 直接用指针访问目标对象成员，无须转换。
}

// 输出:
0x2101ef018, 1234
```

- 不能对指针做加减法等运算。

```go
x := 1234
p := &x
p++          // Error: invalid operation: p += 1 (mismatched types *int and int)
```
- 返回局部变量指针是安全的，编译器会根据需要将其分配在 GC Heap 上。

```go
func test() *int {
    x := 100
    return &x // 使用 runtime.new 分配x内存。但在内联时也可能直接分配在目标栈
}
```

### unsafe.Pointer 与 uintptr

unsafe.Pointer 类似于 C 的 `void *`，在 go 中用于任意类型指针的相互转换。

uintptr 是 go 的内置类型，是一个能够存储指针的整型。其底层类型是 int，与 unsafe.Pointer 可相互转换。

- uintptr 与 unsafe.Pointer的区别

unsafe.Pointer 只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算

uintptr 用于指针运算，GC 不把 uintptr 当指针，而是当做普通整数对象。也就是说 uintptr 无法持有对象，uintptr 类型的目标会被回收。

- 可在 unsafe.Pointer 和任意类型指针间进行转换。

```go
func main() {
    x := 0x12345678
    p := unsafe.Pointer(&x)         // *int -> Pointer
    n := (*[4]byte)(p)              // Pointer -> *[4]byte
    for i := 0; i < len(n); i++ {
        fmt.Printf("%X ", n[i])
    }
}

// 输出:
78 56 34 12
```

- 利用 unsafe 包可操作私有变量。

```go
// 包 p
package p

import (
    "fmt"
)

type V struct {
    i int32
    j int64
}

func (this V) PutI() {
    fmt.Printf("i=%d\n", this.i)
}

func (this V) PutJ() {
    fmt.Printf("j=%d\n", this.j)
}

// 包 main
package main

import (
    "poit/p"
    "unsafe"
)

func main() {
    var v *p.V = new(p.V)    // 分配一段该类型的内存，并返回一个指针
    var i *int32 = (*int32)(unsafe.Pointer(v)) // 将指针 v 转成通用指针，再转成 int32 指针，不可直接转为 int32
    *i = int32(98)    // 设置 v.i 的值
    // 获取 v.j 在内存中的地址
    var j *int64 = (*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + uintptr(unsafe.Sizeof(int32(0)))))
    *j = int64(763)    // 设置 v.j 的值
    v.PutI()
    v.PutJ()
}
```
当然会有些限制，比如需要知道结构体 V 的成员布局，要修改的成员大小以及成员的偏移量。
核心思想是：结构体的成员在内存中的分配是一段连续的内存，结构体中第一个成员的地址就是这个结构体的地址，可认为是相对于这个结构体偏移了0。
以此类推，这个结构体中的任一成员都可以相对于这个结构体的偏移来计算出它在内存中的绝对地址。

上例中 v 的地址其实就是它的第一个成员的地址，所以变量 i 就指向了 v 的成员 i，通过给 i 赋值就相当于给 v.i 赋值了，注意 i 是个指针，要赋值得先解引用。

已经知道 v 是有两个成员的，包括 i 和 j，并且在定义中，i 位于 j 的前面，而 i 是 int32 类型，也就是说 i 占 4 个字节。所以 j 是相对于 v 偏移了 4 个字节。
可用 uintptr(4) 或 uintptr(unsafe.Sizeof(int32(0))) 来做这个事。unsafe.Sizeof方法用来得到一个值应该占用多少个字节空间。
注意这里跟 C 的用法不一样，C 是直接传入类型，而 go 是传入值。之所以转成 uintptr 类型是因为需要做指针运算。
v 的地址加上 j 相对于 v 的偏移地址，也就得到了 v.j 在内存中的绝对地址，注意 j 的类型是 int64，所以现在的 j 就是一个指向 v.j 的指针。

但是上述代码是有一些问题，在 p 目录下 新建 w.go 文件：

```go
package p

import (
    "fmt"
    "unsafe"
)

type W struct {
    b byte
    i int32
    j int64
}

func init() {
    var w *W = new(W)
    fmt.Printf("size = %d\n", unsafe.Sizeof(*w))
}

```
w.go 里定义了一个特殊方法 init，它会在导入 p 包时自动执行，别忘了我们有在 main.go 里导入 p 包。
每个包都可定义多个 init 函数，它们会在包被导入时自动执行(在执行 main 函数前被执行，通常用于初始化工作)，
但是，最好在一个包中只定义一个 init 函数，否则您或许会很难预期它的行为)。看下它的输出:
`size = 16`，貌似与想象的不一样？

好像跟我们想像的不一致。来手动计算一下：
b 是 byte 类型，占 1 个字节；
i 是 int32 类型，占 4 个字节；
j 是 int64 类型，占 8 个字节，1 + 4 + 8 = 13。这是怎么回事呢？这是因为发生了对齐。

在struct中，它的对齐值是它的成员中的最大对齐值。每个成员类型都有它的对齐值，
可用 unsafe.Alignof 计算，如 unsafe.Alignof(w.b) 可得出 b 在 w 中的对齐值。
同理，可计算出 w.b 的对齐值是 1，w.i 的对齐值是 4，w.j 的对齐值也是 4。如果认为 w.j 的对齐值是 8 那就错了，
所以我们前面的代码能正确执行(试想一下，如果w.j的对齐值是8，那前面的赋值代码就有问题了。
也就是说前面的赋值中，如果 v.j 的对齐值是 8，那么 v.i 跟 v.j 之间应该有 4 个字节的填充。所以得到正确的对齐值是很重要的)。
对齐值最小是 1，这是因为存储单元是以字节为单位。所以 b 就在 w 的首地址，而 i 的对齐值是 4，它的存储地址必须是 4 的倍数，
因此，在 b 和 i 的中间有 3 个填充，同理 j 也需要对齐，但因为 i 和 j 之间不需要填充，所以 w 的 Sizeof 值应该是13 + 3 = 16。
如果要通过 unsafe 来对 w 的三个私有成员赋值，b 的赋值同前，而 i 的赋值则需要跳过 3 个字节，也就是计算偏移量的时候多跳过 3 个字节，
同理 j 的偏移可以通过简单的数学运算就能得到。

- go 不支持直接进行指针运算，将 Pointer 转换为 uintptr，可间接实现指针运算。

```go
func main() {
    d := struct {
        s string
        x   int
    }{"abc", 100}
    p := uintptr(unsafe.Pointer(&d))    // *struct -> Pointer -> uintptr
    p += unsafe.Offsetof(d.x)           // uintptr + offset
    p2 := unsafe.Pointer(p)             // uintptr -> Pointer
    px := (*int)(p2)                    // Pointer -> *int
    *px = 200                           // d.x = 200
    fmt.Printf("%#v\n", d)
}

// 输出:
struct { s string; x int }{s:"abc", x:200}
```
