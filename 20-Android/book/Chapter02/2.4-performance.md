Android性能
===

### 0)Render Performance

用户能感知的卡顿主要是因为渲染性能。Android 系统每隔 16ms 发出 VSYNC 信号触发渲染 UI，如果每次渲染都成功，
就能达到流畅画面所需的 60fps。因此大多数操作都应该在 16ms 内完成，
如果某个操作耗费 24ms，系统在得到 VSYNC 信号时无法正常渲染，就发生丢帧现象，用户在 32ms 内看到的会是同一帧画面。

通常，用户在 UI 执行动画或者滑动 ListView 时容易感知到卡顿，原因如下：

1. layout 太过复杂，无法在16ms内完成渲染。
2. UI 上有层叠太多的绘制单元。
3. 动画执行的次数过多。

常用定位工具：

1. 使用 HierarchyViewer 查找 Activity 中布局是否过于复杂。
2. 使用手机设置里面的开发者选项，打开 Show GPU Overdraw 等选项进行观察。
3. 使用 TraceView 观察 CPU 执行情况，排查性能瓶颈。

### 1)Understanding Overdraw

Overdraw（过度绘制）是指屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区域被绘制了多次。浪费大量的 CPU 及 GPU 资源。

可以通过手机设置里面的开发者选项，打开 Show GPU Overdraw 选项，可以观察 UI 上的 Overdraw 情况。
蓝色，淡绿，淡红，深红代表了 4 种不同程度的 Overdraw 情况，应尽量减少红色 Overdraw，看到更多的蓝色区域。

### 2)Understanding VSYNC

要理解 App 是如何进行渲染，必须理解什么是 VSYNC。先介绍两个相关概念：

1. Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的固定参数，如 60Hz。
2. Frame Rate：代表了 GPU 在一秒内绘制操作的帧数，例如 30fps，60fps。

GPU 会获取图形数据进行渲染，然后硬件负责把渲染后的内容呈现到屏幕上，而刷新频率和帧率无法一直保持相同的节奏。
如果发生帧率与刷新频率不一致的情况，就会容易出现 Tearing 现象，画面上下两部分显示内容发生断裂，来自不同的两帧数据发生重叠。

- [理解图像渲染里面的双重与三重缓存机制一](http://source.android.com/devices/graphics/index.html)
- [理解图像渲染里面的双重与三重缓存机制二](http://article.yeeyan.org/view/37503/304664)

通常，帧率超过刷新频率只是理想情况，在超过 60fps 的情况下，
GPU 所产生的帧数据会因为等待 VSYNC 的刷新信息而被 Hold 住，
这样能够保持每次刷新都有实际的新的数据可以显示。但更多的情况是帧率小于刷新频率。
在这种情况下，某些帧显示的画面内容就会与上一帧的画面相同。糟糕的事情是，帧率从超过 60fps 突然掉到 60fps 以下，这样就会发生 LAG，JANK，HITCHING 等卡顿掉帧的不顺滑的情况。

### 3)Tool:Profile GPU Rendering

可通过 android 内置工具来调试性能问题：

1. 打开开发者选项。
2. 选择 Profile GPU Rendering。
3. 选择 On screen as bars。

此时，可在屏幕上看到 GPU 绘制信息，分别关于 StatusBar，NavBar，激活的程序 Activity 区域的 GPU Rending 信息。
随着界面的刷新，界面上会滚动显示垂直的柱状图来表示每帧画面所需要渲染的时间，柱状图越高表示花费的渲染时间越长。
界面上有一根绿色的横线，代表16ms，确保每一帧花费的总时间都低于该横线，即可避免卡顿。

每一条柱状线都包含三部分：

1. 蓝色代表测量绘制 Display List 的时间
2. 红色代表 OpenGL 渲染 Display List 所需要的时间
3. 黄色代表 CPU 等待 GPU 处理的时间。

### 4)Why 60fps?

为何将程序是否达到 60fps 作为 App 性能的衡量标准？因为人眼与大脑之间的协作无法感知超过 60fps 的画面更新。

12fps 大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。
24fps 使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。
24fps 是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。但低于 30fps 无法顺畅表现绚丽的画面内容，需要用到 60fps 来达到想要的效果，当然超过 60fps 是没有必要的。

开发app的性能目标就是保持60fps，这意味着每一帧你只有 16ms = 1000 / 60 的时间来处理所有任务。

### 5)Android, UI and the GPU

了解 Android 是如何利用 GPU 进行画面渲染有助于更好的理解性能问题。那么一个最实际的问题是：
activity 的画面是如何绘制到屏幕上的？那些复杂的 XML 布局文件又是如何被识别并绘制的？

Resterization 栅格化是绘制 Button，Shape，Path，String，Bitmap 等组件最基础的操作。
它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU 的引入就是为了加快栅格化的操作。
CPU 负责把 UI 组件计算成 Polygons，Texture 纹理，然后交给 GPU 进行栅格化渲染。
然而每次从 CPU 转移到 GPU 是一件很麻烦的事情，所幸的是 OpenGL ES 可以把那些需要渲染的纹理 Hold 在 GPU Memory里，
在下次需要渲染的时候直接进行操作。所以更新了 GPU 所 hold 住的纹理内容，之前保存的状态就丢失了。

在 Android 中的 Bitmaps，Drawables 都是一起打包到统一的 Texture 纹理中，再传递到 GPU 里，
这意味着每次需要使用这些资源时，都是直接从纹理中获取渲染。当然随着 UI 组件的越来越丰富，有了更多演变的形态。
例如显示图片的时候，需要先经过 CPU 的计算加载到内存中，然后传递给 GPU 进行渲染。
文字的显示更加复杂，需要先经过 CPU 换算成纹理，然后再交给 GPU 进行渲染，回到 CPU 绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则是一个更加复杂的操作流程。

为了能够使得 App 流畅，我们需要在每一帧 16ms 以内处理完所有的 CPU 与 GPU 计算，绘制，渲染等等操作。

### 7)Overdraw, Cliprect, QuickReject

非可见的 UI 组件进行绘制更新会导致 Overdraw，Android 系统会通过避免绘制那些完全不可见的组件来尽量减少 Overdraw。
但对于自定义的 View (重写了 onDraw 方法)，Android 系统无法检测具体在 onDraw 里面会执行什么操作，系统无法监控并自动优化，也就无法避免 Overdraw。
但可通过如下方法进行优化：

1. 通过 canvas.clipRect() 指定一块矩形区域，只有在该区域内才会被绘制，其他的区域会被忽视。
2. 使用 canvas.quickreject() 判断是否和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。

### 8)Memory Churn and performance

虽然 Android 有自动管理内存的机制，但是对内存的不恰当使用仍然容易引起严重的性能问题。在同一帧里面创建过多的对象是件需要特别引起注意的事情。

Android 系统里面有一个 Generational Heap Memory 的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。
例如，最近刚分配的对象会放在 Young Generation 区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，
同时这个区域的 GC 操作速度也是比 Old Generation 区域的 GC 操作速度更快

除了速度差异之外，执行 GC 操作的时候，任何线程的任何操作都会需要暂停，等待 GC 操作完成之后，其他操作才能够继续运行。

通常来说，单个的 GC 并不会占用太多时间，但是大量不停的 GC 操作则会显著占用帧间隔时间(16ms)。
如果在帧间隔时间里面做了过多的 GC 操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。

导致GC频繁执行有两个原因：

1. Memory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。
2. 瞬间产生大量的对象会严重占用Young Generation 的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。
即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加 Heap 的压力，从而触发更多其他类型的GC。
这个操作有可能会影响到帧率，并使得用户感知到性能问题。

常见内存抖动现象：

1. 在 Memory Monitor 里面查看到短时间发生了多次内存的涨跌，很有可能发生了内存抖动。
2. 通过 Allocation Tracker 来查看在短时间内，同一个栈中不断进出的相同对象，，也是内存抖动的典型信号之一。

建议：

1. 免在 For 循环里分配对象占用内存。
2. 避免在自定义 View 中的 onDraw 方法。
3. 对于那些无法避免需要创建对象的情况，可考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，注意结束使用之后，手动释放对象池中的对象。

### 9)Garbage Collection in Android

原始 JVM 中的 GC 机制在 Android 中得到了很大程度上的优化。
Android 里面是一个三级 Generation 的内存模型，最近分配的对象会存放在 Young Generation 区域，
当这个对象在这个区域停留的时间达到一定程度，它会被移动到 Old Generation，最后到 Permanent Generation 区域。

每一个级别的内存区域都有固定的大小，此后不断有新的对象被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会触发 GC 的操作，以便腾出空间来存放其他新的对象。
每次 GC 发生的时候，所有的线程都是暂停状态的

Young Generation的每次 GC 操作时间是最短的，Old Generation其次，Permanent Generation最长。
执行时间的长短也和当前Generation中的对象数量有关，遍历查找20000个对象比起遍历50个对象自然是要慢很多的。

### 10)Performance Cost of Memory Leaks

内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。

寻找内存泄漏并修复这个漏洞是件很棘手的事情，你需要对执行的代码很熟悉，清楚的知道在特定环境下是如何运行的，然后仔细排查。例如，你想知道程序中的某个activity退出的时候，它之前所占用的内存是否有完整的释放干净了？首先你需要在activity处于前台的时候使用Heap Tool获取一份当前状态的内存快照，然后你需要创建一个几乎不这么占用内存的空白activity用来给前一个Activity进行跳转，其次在跳转到这个空白的activity的时候主动调用System.gc()方法来确保触发一个GC操作。最后，如果前面这个activity的内存都有全部正确释放，那么在空白activity被启动之后的内存快照中应该不会有前面那个activity中的任何对象了。

如果你发现在空白activity的内存快照中有一些可疑的没有被释放的对象存在，那么接下去就应该使用Alocation Track Tool来仔细查找具体的可疑对象。我们可以从空白activity开始监听，启动到观察activity，然后再回到空白activity结束监听。这样操作以后，我们可以仔细观察那些对象，找出内存泄漏的真凶。

### 11)Memory Performance

通常来说，Android对GC做了大量的优化操作，虽然执行GC操作的时候会暂停其他任务，可是大多数情况下，GC操作还是相对很安静并且高效的。但是如果我们对内存的使用不恰当，导致GC频繁执行，这样就会引起不小的性能问题。

为了寻找内存的性能问题，Android Studio提供了工具来帮助开发者。

Memory Monitor：查看整个app所占用的内存，以及发生GC的时刻，短时间内发生大量的GC操作是一个危险的信号。
Allocation Tracker：使用此工具来追踪内存的分配，前面有提到过。
Heap Tool：查看当前内存快照，便于对比分析哪些对象有可能是泄漏了的，请参考前面的Case。
12)Tool - Memory Monitor

Android Studio中的Memory Monitor可以很好的帮组我们查看程序的内存使用情况。

### 13)Battery Performance

电量其实是目前手持设备最宝贵的资源之一，大多数设备都需要不断的充电来维持继续使用。不幸的是，对于开发者来说，电量优化是他们最后才会考虑的的事情。但是可以确定的是，千万不能让你的应用成为消耗电量的大户。

Purdue University研究了最受欢迎的一些应用的电量消耗，平均只有30%左右的电量是被程序最核心的方法例如绘制图片，摆放布局等等所使用掉的，剩下的70%左右的电量是被上报数据，检查位置信息，定时检索后台广告信息所使用掉的。如何平衡这两者的电量消耗，就显得非常重要了。

有下面一些措施能够显著减少电量的消耗：

我们应该尽量减少唤醒屏幕的次数与持续的时间，使用WakeLock来处理唤醒的问题，能够正确执行唤醒操作并根据设定及时关闭操作进入睡眠状态。
某些非必须马上执行的操作，例如上传歌曲，图片处理等，可以等到设备处于充电状态或者电量充足的时候才进行。
触发网络请求的操作，每次都会保持无线信号持续一段时间，我们可以把零散的网络请求打包进行一次操作，避免过多的无线信号引起的电量消耗。关于网络请求引起无线信号的电量消耗，还可以参考这里http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html
我们可以通过手机设置选项找到对应App的电量消耗统计数据。我们还可以通过Battery Historian Tool来查看详细的电量消耗。

如果发现我们的App有电量消耗过多的问题，我们可以使用JobScheduler API来对一些任务进行定时处理，例如我们可以把那些任务重的操作等到手机处于充电状态，或者是连接到WiFi的时候来处理。 关于JobScheduler的更多知识可以参考http://hukai.me/android-training-course-in-chinese/background-jobs/scheduling/index.html

### 14)Understanding Battery Drain on Android

电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗。

当设备处于待机状态时消耗的电量是极少的，以N5为例，打开飞行模式，可以待机接近1个月。可是点亮屏幕，硬件各个模块就需要开始工作，这会需要消耗很多电量。

使用WakeLock或者JobScheduler唤醒设备处理定时的任务之后，一定要及时让设备回到初始状态。每次唤醒无线信号进行数据传递，都会消耗很多电量，它比WiFi等操作更加的耗电，详情请关注http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html

修复电量的消耗是另外一个很大的课题，这里就不展开继续了。

### 15)Battery Drain and WakeLocks

高效的保留更多的电量与不断促使用户使用你的App来消耗电量，这是矛盾的选择题。不过我们可以使用一些更好的办法来平衡两者。

假设你的手机里面装了大量的社交类应用，即使手机处于待机状态，也会经常被这些应用唤醒用来检查同步新的数据信息。Android会不断关闭各种硬件来延长手机的待机时间，首先屏幕会逐渐变暗直至关闭，然后CPU进入睡眠，这一切操作都是为了节约宝贵的电量资源。但是即使在这种睡眠状态下，大多数应用还是会尝试进行工作，他们将不断的唤醒手机。一个最简单的唤醒手机的方法是使用PowerManager.WakeLock的API来保持CPU工作并防止屏幕变暗关闭。这使得手机可以被唤醒，执行工作，然后回到睡眠状态。知道如何获取WakeLock是简单的，可是及时释放WakeLock也是非常重要的，不恰当的使用WakeLock会导致严重错误。例如网络请求的数据返回时间不确定，导致本来只需要10s的事情一直等待了1个小时，这样会使得电量白白浪费了。这也是为何使用带超时参数的wakelock.acquice()方法是很关键的。但是仅仅设置超时并不足够解决问题，例如设置多长的超时比较合适？什么时候进行重试等等？

解决上面的问题，正确的方式可能是使用非精准定时器。通常情况下，我们会设定一个时间进行某个操作，但是动态修改这个时间也许会更好。例如，如果有另外一个程序需要比你设定的时间晚5分钟唤醒，最好能够等到那个时候，两个任务捆绑一起同时进行，这就是非精确定时器的核心工作原理。我们可以定制计划的任务，可是系统如果检测到一个更好的时间，它可以推迟你的任务，以节省电量消耗。

这正是JobScheduler API所做的事情。它会根据当前的情况与任务，组合出理想的唤醒时间，例如等到正在充电或者连接到WiFi的时候，或者集中任务一起执行。我们可以通过这个API实现很多免费的调度算法。

从Android 5.0开始发布了Battery History Tool，它可以查看程序被唤醒的频率，又谁唤醒的，持续了多长的时间，这些信息都可以获取到。
