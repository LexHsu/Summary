
内存管理
=========

### 动态内存释放与野指针
当使用free()和delete释放一块内存时，指针还是指向原来的地址，不过这时候的指针时野指针，那块内存数据是未知的:
- 指针销毁了，所指的空间没有释放，即内存泄露。
- 内存被释放了，指针没有置为NULL，即野指针。

### 内存的常见分配方式

- 从静态区分配，一般是全局变量和 static 类型变量
- 从栈区分配内存，一般是局部的变量，会随着所在函数的结束而自动释放
- 从堆中分配，一般是使用手动分配，使用 malloc() 函数和 new 来申请任意大小空间，不过要手动释放空间，相应的使用 free() 函数和 delete 释放，
如果不释放该空间，而且指向该空间的指针指向了别的空间.则该空间就无法释放，造成内存泄露，造成了内存浪费

### 内存使用规则
- 在使用  malloc() 或 new 申请空间时，要检查有没有分配空间成功，判断方法是判断指针是否为 NULL，
如申请一块很大的内存而没有这么大的内存则分配内存会失败，因此分配完空间后，要判断指针是否为 NULL。
- 申请成功后最好是将该内存清空，使用 memset() 后 ZeroMemory() 清空，不然存在垃圾而造成有时候输出很大乱码
- 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
- 要防止数组或指针内存越界，
- 申请内存成功后，使用结束后要释放，系统不会自动释放手动分配的内存
- 内存释放后，指针还是指向那块地址，不过该指针已经是“野指针”了，所以释放内存后指针要指向 NULL ，不然很危险，容易出错。

给指针分配内存主要有两种：

一种是在堆上分配一块内存(动态分配内存)，让指针指向这块内存。

第二种是指针指向栈上的一块内存(一般是定义一个非指针变量，让指针指向这个变量)。

```c
#include <stdio.h>
#include <malloc.h>

int main() {
    // 第一种
    int *p1 = (int*)malloc(sizeof(int)); // 动态的在堆上分配一块内存(手动分配)
    scanf("%d", p1);
    printf("%d/n", *p1);
    free(p1);                        // 释放内存

    // 第二种
    int  i;                          // 由系统自动在栈上分配一块内存，不需要用户管理，如 free
    int  *p2 = NULL;
    scanf("%d", &i);
    p2 = &i;                         // 将 p2 指向栈上 i 的内存
    printf("%d/n", *p2);
    return 0;  
}
```

### 指针与数组

数组可修改，但指针指向的常量字符串不可修改，虽然编译器编译时不会保存，但执行时会出错。

```c
int main() {
    char str[] = "hello"; // 存储了6个字符 "hello\0"
    char *p = "word";     // 指针指向了常量字符串，常量字符串不可修改
    str[0] = 'x';         // 正确
    // p[0] = 'x';        // 编译器不会报错，但执行会出错
    printf("%s\n", str); // xello
    printf("%c\n", *p);   // w
    printf("%c\n", p[0]); // w
    printf("%s\n", p);    // word
    return 0;
}
```

- 内容复制使用 strcpy() 函数，内容比较使用 strcmp() 函数。

```c
// 数组例子
char a[] = "hello";
char b[10];
strcpy(b, a);           // 不能用 b = a;
if(strcmp(b, a) == 0)   // 不能用 if (b == a)

// 指针例子
int len = strlen(a);
char *p = (char *)malloc(sizeof(char)*(len+1));
strcpy(p, a);            // 不可用 p = a;
if(strcmp(p, a) == 0)   // 不可用 if (p == a)
```

对数组的计算是使用 sizeof() ，该函数会按照内存对齐的方式 4 的倍数计算，而指针的空间大小没法计算，只能记住在申请空间时的空间大小。
注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针，不论数组a的容量是多少，sizeof(a) 始终等于 sizeof(char *)。

```c
void Func(char a[100]) {
    printf("%s/n", sizeof(a));  // 4，不是 100
}
```

### 指针的内存的传递
如果函数的参数是指针，则不可使用该参数来申请内存空间，这样没有实际的用处，而且这样当函数结束时还得不到释放内存而造成内存泄露

```c
#include<iostream>
using namespace std;

void GetMemory(char *p) {
    p = NULL;
    p = (char *)malloc(sizeof(char));
    memset(p, 0, sizeof(char));
    if (p) {
        printf("p 申请内存成功/n");
    }
}

int main() {
    char *p1 = NULL;
    GetMemory(p1);
    if (p1) {
        printf("p1 申请内存成功/n");
    } else {
        printf("p1 申请内存不成功/n");
    }
    return 0;
}

// result:
// p 申请内存成功
// p1 申请内存不成功
// 可以看到 p1 值为 0X00000000
```
这是因为传入函数 GetMemory 内的是指针p的副本，因此是其副本新分配了空间，而 p 未变。要想改变 p 的值可传入指向 p 的指针，即二级指针。

解决方法一，指针的指针：

```c
// 指针的指针方式
void GetMemory(char **p) {
    *p = NULL;
    *p = (char *)malloc(sizeof(char));
    memset(p, 0, sizeof(char));
    if (*p) {
        printf("p 申请内存成功/n");
    }
}

int main() {
    char *p1 = NULL;
    GetMemory(&p1); // 这里是&p1
    if (p1) {
        printf("p1 申请内存成功/n");
    } else {
        printf("p申请内存不成功/n");
    }
    return 0;
}
// result:
// p 申请内存成功
// p1 申请内存成功
// 可以看到 p1 值类似于 ox005e26a0
```

解决方法二，返回内存地址：
```c

// 返回地址
char * GetMemory() {
    char *p = NULL;
    p = (char *)malloc(sizeof(char)); // 在堆上动态分配
    memset(p, 0, sizeof(char));
    return p;
}

int main() {
    char *p1 = NULL;
    p1 = GetMemory();
    if (p1) {
        printf("p1 申请内存成功/n");
    } else {
        printf("p1 申请内存不成功/n");
    }
    return 0;
}
// result:
// p1 申请内存成功
// 可以看到 p1 值类似于 ox003e26a0
```

但是，使用返回内存地址的方式容易出错，上面例子是通过 malloc 动态分配在堆上，
GetMemory 函数调用结束不会释放，而如果是在栈上分配的，
如函数内的数组，当 GetMemory() 函数结束时栈内存也被释放，因此"栈内存"的指针便是乱码。

```c
// 返回栈内存地址
char *GetMemory() {
    char p[] = "hello world"; // 栈上分配
    return p;
}

int main() {
    char *p1 = NULL;
    p1 = GetMemory();
    if (p1) {
        printf("p1 申请内存成功/n");
        printf("%s/n", p1); // 输出乱码
    } else {
        printf("p1 申请内存不成功/n");
    }
    return 0;
}

// result:
// p1 申请内存成功
// @%%%@~
// 可以看到 p1 值类似于 ox0012fee4"烫烫?@"
```

再看一个例子

```c
char *getString(void) {
    char *p = "hello world";
    return p;
}

int main() {
    char *str = NULL;
    str = getString2();
    printf("%s/n", str);
    return 0;
}
```

虽然运行结果是正确的，但是函数 GetString 的实现思路却是错误的。因为 GetString 内的 “hello world”是常量字符串，位于静态存储区，
其在程序生命期内恒定不变。无论什么时候调用getString，返回的始终是同一个“只读”的内存块。
