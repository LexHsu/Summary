闭包
===

理解闭包之前先理解如下概念：

1. 第一类值（first-class value）：在Lua中函数和其他值（数值、字符串等）一样，可存放在变量中，也可以存放在表中，可以作为函数的参数，还可以作为函数的返回值，统称为第一类值。
2. 词法定界（lexical scoping）：假设函数f2定义在函数f1中，那么就称f2为f1的内嵌(inner)函数，f1为f2的外包(enclosing)函数，外包和内嵌都具有传递性，即f2的内嵌必然是f1的内嵌，而f1的外包也一定是f2的外包。内嵌函数能访问外包函数已创建的所有局部变量，这种特性便是所谓的词法定界，而这些局部变量则称为该内嵌函数的外部局部变量(external local variable)或upvalue。

既然lua中的函数也是第一类指，定义函数就象创建普通类型值一样(只不过函数类型值的数据主要是一条条指令而已)，所以在函数体中仍然能定义函数。如下代码：

```lua
function f1(n)
   -- 函数参数也是局部变量
   local function f2()
      print(n) -- 引用外包函数的局部变量
   end
   return f2
end


g1 = f1(1)
g1() -- 打印出1
g2 = f1(2)
g2() -- 打印出2
```

当执行完g1 = f1(1)后，局部变量n的生命周期本该结束，但因为他已成了内嵌函数f2(他又被赋给了变量g1)的upvalue，所以他仍然能以某种形式继续存活下来，从而令g1()打印出正确的值。
可为什么g2和g1的函数体相同(都是f1的内嵌函数f2的函数体)，但打印值不同？这就涉及到一个相当重要的概念——闭包(closure)。

Lua编译一个函数时，会为他生成一个原型(prototype)，其中包含：

1. 函数体对应的虚拟机指令
2. 函数用到的常量值(数，文本字符串等等)
3. 一些调试信息

在运行时，每当Lua执行一个形如function...end 这样的表达式时，会创建一个新的数据实体，其中包含：

1. 相应函数原型的引用
2. 环境(environment，用来查找全局变量的表)的引用
3. 一个由所有upvalue(外部局部变量)引用组成的数组

可见函数是编译期概念，是静态的，而闭包是运行期概念，是动态的。这种由引用环境与函数代码组成的实体就是闭包。闭包不是函数，只是行为和函数相似，不是所有被传递的函数都需要转化为闭包，只有引用环境可能发生变化的函数才需要这样做。

g1和g2的值严格来说不是函数而是闭包，并且是两个不相同的闭包，而每个闭包能保有自己的upvalue值，所以g1和g2打印出的结果当然就不相同了。使用upvalue非常方便，但他们的语义也非常微妙，需要引起注意。比如将f1函数改成：

```lua
function f1(n)
   local function f2()
      print(n)
   end
   n = n + 1
   return f2
end

g1 = f1(1)
g1() -- 打印出2
```

内嵌函数定义在n = n + 10这条语句之前，可为什么g1()打印出的却是2？

upvalue实际是局部变量，而局部变量是保存在函数堆栈上的，所以只要upvalue还没有离开自己的作用域，他就一直生存在函数堆栈上。这种情况下，闭包将通过指向堆栈上的upvalue的引用来访问他们，一旦upvalue即将离开自己的作用域(这也意味着他马上要从堆栈中消失)，闭包就会为他分配空间并保存当前的值，以后便可通过指向新分配空间的引用来访问该upvalue。当执行到f1(1)的n = n + 1时，闭包已创建了，不过n并没有离开作用域，所以闭包仍然引用堆栈上的n，当return f2完成时，n即将结束生命，此时闭包便将n(已是2了)复制到自己管理的空间中以便将来访问。弄清晰了内部的秘密后，运行结果就不难解释了。

upvalue还能为闭包之间提供一种数据共享的机制。试看下例：

```lua
function Create(n)
   local function foo1()
      print(n)
   end
   local function foo2()
      n = n + 1
   end
   return foo1,foo2
end

f1,f2 = Create(1)
f1() -- 打印1
f2()
f1() -- 打印2
f2()
f1() -- 打印3
```

f1,f2这两个闭包的原型分别是Create中的内嵌函数foo1和foo2，而foo1和foo2引用的upvalue是同一个，即Create的局部变量n。前面已说过，执行完Create调用后，闭包会把堆栈上n的值复制出来，那么是否f1和f2就分别拥有一个n的拷贝呢？其实不然，当Lua发现两个闭包的upvalue指向的是当前堆栈上的相同变量时，会聪明地只生成一个拷贝，然后让这两个闭包共享该拷贝，这样任一个闭包对该upvalue进行修改都会被另一个探知。上述例子非常清晰地说明了这点：每次调用f2都将upvalue的值增加了1，随后f1将更新后的值打印出来。upvalue的这种语义非常有价值，他使得闭包之间能不依赖全局变量进行通讯，从而使代码的可靠性大大提高。

闭包在创建之时其upvalue就已不在堆栈上的情况也有可能发生，这是因为内嵌函数能引用更外层外包函数的局部变量：

```lua
function Test(n)
   local function foo()
      local function inner1()
         print(n)
      end
      local function inner2()
         n = n + 1
      end
      return inner1,inner2
   end
   return foo
end

t = Test(1)
f1,f2 = t()
f1()        -- 打印1
f2()
f1()        -- 打印2
g1,g2 = t()
g1()        -- 打印2
g2()
g1()        -- 打印3
f1()        -- 打印3
```

执行完t = Test(1)后，Test的局部变量n生命周期就已结束，当f1、f2如果在当前堆栈上未找到n就会自动到他们的外层闭包的upvalue引用数组中去找，并把找到的引用值拷贝到自己的upvalue引用数组中。g1和g2和f1和f2都是同一个闭包(t)创建的，所以他们引用的upvalue(n)实际也是同一个变量。下面的例子便是分别创建不同的闭包：

```lua
function makeCounter()
    local count = 0
    function incCount()
        count = count + 1
        return count
    end
    return incCount
end

c1 = makeCounter()
c2 = makeCounter()

print(c1())       -- 打印1
print(c1())       -- 打印2
print(c2())       -- 打印1
print(c1())       -- 打印3
print(c2())       -- 打印2
```

再次观察上面两个例子会发现，代码中并没有通过名字来调用函数 inc_count 和 addsum，所以他们根本不需要名字。以第一段代码为例，可等价于：

```lua
function makeCounter()
    local count = 0
    return function()
        count = count + 1
        return count
    end
end

c1 = makeCounter()
c2 = makeCounter()

print(c1())       -- 打印1
print(c1())       -- 打印2
print(c2())       -- 打印1
print(c1())       -- 打印3
print(c2())       -- 打印2
```

这里使用了匿名函数。使用匿名函数能使代码得到简化。总体而言，和闭包相关连的概念有：

1. 函数是一阶值；
2. 函数可以嵌套定义；
3. 可以捕获引用环境，并把引用环境和函数代码组成一个可调用的实体；
4. 允许定义匿名函数；

这些条件并不是必要的，但具备这些条件能说明一个编程语言对闭包的支持较为完善。借用一个非常好的说法来做个总结：对象是附有行为的数据，而闭包是附有数据的行为。

### 重新理解闭包

为什么大家叫闭包, 不叫它函数，可见函数不是闭包。c 语言中的函数的定义是: 对功能的抽象块;lua中对函数做了扩展:

1. 可以把一个或多个值与函数绑定在一起, 这些值被称为upvalue.
2. 每个函数可以和一个env(环境)绑定，env是非常重要和有用的东西, 它可以轻松创造出一个受限的环境, 就是传说中的"沙盒"。

```
c   函数 { 功能抽象 }
lua 闭包 {功能抽象, upvalue, env}
```

如果把lua中的{功能抽象, upvalue, env}也称为函数, 不但容易引起大家的误解以为它就是和c函数一样, 而且它确实不能很好的表达出lua函数的丰富内涵, 闭包, "闭" 是指的它是一个object, 一个看得见摸得着的东西, 不可分割的整体(first class); "包" 指的是它包含了功能抽象, upvalue, env. 这里一个很有趣的事实就是, {功能抽象, upvalue, env}是很多动态语言的一个实现特征, 比如lua, javascript都有实现这样的结构, 它是先被实现出来, 然后冠以"闭包"这样一个名称。