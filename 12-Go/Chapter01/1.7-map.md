Map=========引用类型，哈希表。键必须是支持相等运算符(==, !=)类型，比如number，string，pointer，array，struct，以及对应的interface。值可以是任意类型。```gom := map[int]struct {    name string    age int}{    1:  {"user1", 10}, // 可省略元素类型    2:  {"user2", 20},}println(m[1].name)```- 可预先给make函数一个合理元素数量参数，有助于提升性能。因为事先申请一大块内存，可避免后续操作时频繁扩张。```gom := make(map[string]int, 1000)```- 常见操作```gom := map[string]int{    "a": 1,}if v, ok := m["a"]; ok {    //判断key是否存在    println(v)}println(m["c"])             // 对于不存在的key，直接返回 \0，不会出错m["b"] = 2                  // 新增或修改delete(m, "c")              // 删除，如果key不存在,不会出错println(len(m))             // 获取键值对数量，cap无效for k, v := range m {       // 迭代，可仅返回key    println(k, v)}```- 不能保证迭代次序和添加时相同,具体结果和不同版本的实现有关。- 从map中取回的是一个value的临时拷贝，对其成员的修改没有任何意义。```gotype user struct{ name string }m := map[int]user{    1: {"user1"},}m[1].name = "Tom"         // Error: cannot assign to m[1].name// 正确的做法是完整替换或使用指针u := m[1]u.name = "Tom"m[1] = u                // 替换 valuem2 := map[int]*user{    1: &user{"user1"},}m2[1].name = "Jack"     // 返回的是指针复制品。透过指针修改原对象是允许的```- 可以在迭代时安全删除键值。但如果期间有新增操作，结果则无法预知。```gofor i := 0; i < 5; i++ {    m := map[int]string{        0:  "a", 1:  "a", 2:  "a", 3:  "a", 4:  "a",        5:  "a", 6:  "a", 7:  "a", 8:  "a", 9:  "a",    }    for k := range m {        m[k+k] = "x"        delete(m, k)}    fmt.Println(m)}// 输出：map[12:x 16:x 2:x 6:x 10:x 14:x 18:x]map[12:x 16:x 20:x 28:x 36:x]map[12:x 16:x 2:x 6:x 10:x 14:x 18:x]map[12:x 16:x 2:x 6:x 10:x 14:x 18:x]map[12:x 16:x 20:x 28:x 36:x]```