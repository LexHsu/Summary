字符数组与字符指针
===

### 字符数组

- 初始化。

```c
char a[10]="hello";               // 1.定义候直接用字符串赋值
char a[10];
a = "hello";                      // 错误，a 指针已经指向在堆栈中分配的10个字符空间，且 a 是常量指针 const *a
char a[10]={'h','e','l','l','o'}; // 2.对数组中字符逐个赋值
char a[10]; strcpy(a, "hello");   // 3.strcpy
```

### 字符指针

- 初始化。

```c
char *p,a='5';
p = &a;          // OK
p = "hello";     // OK，注意与字符数组初始化的区别，上例的 a 其实是一个常量指针
```
可见，但可以赋值给字符指针，初始化时，其做了3件事：
1. 申请了空间(在静态常量区)，存放了字符串。
2. 在字符串尾加上了`'\0'`。
3. 返回这些字符存储的地址。

注意：
在指针运算时，编译器会自动识别类型，如 int 型指针要获取下一个地址，直接 p++ 即可，不需要 p + 4。
void 指针不可进行指针运算，应为void型编译器不能识别类型的长度（即指针所指对象的体积），如 `p++` 是非法的，
既不可进行数学运算，也不可使用 `*` 取值操作，想使用必须转换为具体指针类型。

### 字符串是常量？

编译器都会为字符串自动添加一个0作为结束符，如在代码中写 `"abc"`，编译器自动存储为`"abc\0"`。

- 字符串赋值给字符数组。
```c
char str[] = "abc";  // 等价于 char str[4] = {'a','b','c','\0'};
```
- 字符串赋值给字符指针。

```c
char *p = "abc";     // 字符串"abc\0"分配在常量区，若在函数内，p 在栈上
ptr[0] = 'x';        // 编译可通过，但运行时异常，常量区中的数据不可修改
```
- 数组的类型是由该数组所存放的东西的类型以及数组本身的大小决定

如char s1[3]和 char s2[4]，s1 的类型就是 char[3]，s2 的类型就是char[4]，尽管s1和s2都是字符数组，但两者的类型却是不同的。
"abc" 即可认为是 const char[7]。

- sizeof 用于求类型的字节数。如int a;那么无论sizeof(int)或者是sizeof(a)都
是等于4，因为sizeof(a)其实就是sizeof(type of a)
