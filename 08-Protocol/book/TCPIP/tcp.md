TCP 三次握手与四次挥手
===


[tcp](img/tcp.jpg)

### 三次握手

1. 第一次握手：客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；客户端进入 SYN_SEND 状态，等待服务器确认；
2. 第二次握手：服务器收到客户端的 SYN 报文段，需要对这个SYN报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时，自己自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上述所有信息放到一个报文段（即 SYN + ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态；
3. 第三次握手：客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y + 1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。

### 为何需要三次握手

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，防止服务器一直等待浪费资源。举例说明“已失效的连接请求报文段”发生场景：

1. client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留，延迟到连接释放以后才到达server。
本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。
2. 如果不采用“三次握手”，只要 server 发出确认，新的连接就会建立。而 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据，但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据，耗费 server 资源。
3. 而采用“三次握手”，client 不会对 server 响应进行确认。server 收不到确认，可知 client 并没有要求建立连接，从而防止耗费服务器资源。


### 四次挥手

1. 第一次分手：主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number，向主机 2 发送一个 FIN 报文段；此时主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 不会再发数据给主机 2；
2. 第二次分手：主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number + 1 ；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，不会再发送数据，可以关闭连接；
3. 第三次分手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 CLOSE_WAIT 状态；
4. 第四次分手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，主机 1 也关闭连接。


### 为何需要四次挥手

TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机 1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送给主机 2，但主机 1  可能会收到主机 2  发送的数据；主机 2 同理。


1. FIN_WAIT_1: 这个状态要好好解释一下，其实 FIN_WAIT_1 和 FIN_WAIT_2 状态的真正含义都是表示等待对方的 FIN 报文。
而这两种状态的区别是：FIN_WAIT_1 状态实际上是当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时该 SOCKET 即进入到 FIN_WAIT_1 状态。而当对方回应 ACK 报文后，则进入到 FIN_WAIT_2 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以 FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态还有时常常可以用 netstat 看到。（主动方）
2. FIN_WAIT_2：实际上 FIN_WAIT_2 状态下的 SOCKET 表示半连接，有一方要求 close 连接，但另外还告诉对方，还有点数据需要传送(ACK 信息)，稍后再关闭连接。（主动方）
CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）
3. LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）
4. TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）
CLOSED: 表示连接中断。

### 附录

1. 全双工：指可以同时进行信号的双向传输（A→B 且 B→A）。指A→B的同时B→A，是瞬时同步的，如打电话，可听到对方说话的同时，也可以说话。
2. 半双工：指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。通信信道的每一段都可以是发送端，也可以是接收端。但同一时刻里，信息只能有一个传输方向。如潮汐车道。
