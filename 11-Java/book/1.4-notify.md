wait与notify
===

wait与notify是java同步机制中重要的组成部分。结合synchronized关键字，可建立优秀的同步模型。
```java
synchronized(this) { }
// 等价于
public synchronized void method() {.....}
```

### 同步分类

分为类级别和对象级别，分别对应着类锁和对象锁。每个类只有一个类锁，如static的方法被synchronized关键字修饰，这个方法被执行前必须获得类锁；对象锁类同。

### wait()

调用 wait() 方法时，该对象上的锁被释放，该线程阻塞，在synchronied块中的代码不会往下执行。只有当线程被唤醒时，才会去获得对象锁。

### notify()

唤醒一个等待该对象同步锁的线程，若有多个等待的线程，由JVM确定唤醒哪个线程，而不是按优先级。

### notifyAll()

唤醒所有wait的线程，注意唤醒的是notify之前wait的线程，对于notify之后的wait线程无效。
通常，多线程之间需要协调工作：如果条件不满足，则等待；当条件满足时，等待该条件的线程将被唤醒。在Java中，这个机制的实现依赖于wait/notify。等待机制与锁机制是密切关联的。如：

```java
synchronized(obj) {
    while (!condition) {
        obj.wait();
    }
    obj.doSomething();
}
　　
当线程A获得了obj锁后，发现条件condition不满足，无法继续下一处理，于是线程A就wait()。
在另一线程B中，如果B更改了某些条件，使得线程A的condition条件满足了，即可唤醒线程A。
　　
synchronized(obj) {
    condition = true;
    obj.notify();
}
```

注意：
　　
1. 调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在 `synchronized(obj){...}` 代码段内。
否则虽然可以编译通过，但是抛出IllegalMonitorStateException异常。
2. 调用obj.wait()后，线程A就释放了obj的锁，否则线程B无法获得obj锁，也就无法在`synchronized(obj){...}` 代码段内唤醒A。
3. 当obj.wait()方法返回后，线程A需要再次获得obj锁，才能继续执行。
4. 如果A1,A2,A3都在obj.wait()，则B调用obj.notify()只能唤醒A1,A2,A3中的一个（由JVM决定）。
obj.notifyAll()则能全部唤醒A1,A2,A3，但是要继续执行obj.wait()的下一条语句，必须获得obj锁，
因此，A1,A2,A3只有一个有机会获得锁继续执行，例如A1，其余的需要等待A1释放obj锁之后才能继续执行。
当B调用obj.notify/notifyAll的时候，B正持有obj锁，因此，A1,A2,A3虽被唤醒，但是仍无法获得obj锁。直到B退出synchronized块，释放obj锁后，A1,A2,A3中的一个才有机会获得锁继续执行。
　　
### 总结

1. 有synchronized的地方不一定有wait,notify
2. 有wait,notify的地方必有synchronized。因为wait和notify不是属于线程类，而是每一个对象都具有的方法，
而且，这两个方法都和对象锁有关，有锁的地方，必有synchronized。
3. 同时notify和wait方法，必须先调用notify后调用wait，因为如果调用完wait，该线程就已经不是currentthread了。
